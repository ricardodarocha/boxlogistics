# Boas prÃ¡ticas

Este documento orienta os programadores do time a aderir ao guia de boas prÃ¡ticas, baseado nos conceitos mais modernos de boas prÃ¡ticas de desenvolvimento da comunidade de software.
 - Ergonomia: SÃ£o as decisÃµes de fluxo de trabalho, equipamentos, ambiente e ferramentas do dia a dia que propiciem boa qualidade de vida, clareza, acessibilidade e bem estar dos programadores e testadores.
 - Clean Code: CÃ³digo Limpo Ã© uma premissa de organizaÃ§Ã£o de cÃ³digo, escrita de cÃ³digo claro, de fÃ¡cil leitura, fÃ¡cil de dar manutenÃ§Ã£o e com baixa carga cognitiva (baixo tempo de aprendizado).
 - SOLID: SOLID sÃ£o princÃ­pios de ProgramaÃ§Ã£o Orientada a Objetos POO mas que sÃ£o aplicÃ¡veis em certa medida em todos os tipos de sistema, consitem em criar cÃ³digo preciso, unitÃ¡rio, coezo e com nÃ­veis certos de abstraÃ§Ã£o.
 - KISS: Sigla para Keep It Stupdly Simple, uma premissa que norteia a criaÃ§Ã£o de cÃ³digo simples, que exija o menor esforÃ§o possÃ­vel para a soluÃ§Ã£o do problema do domÃ­nio especÃ­fico
 - DRY: Sigla para _Dont Repeat Yourself_ um lema do reaproveitamento de cÃ³digo e organizaÃ§Ã£o de modo a compartilhar cÃ³digo entre diferentes projetos ou de projetar fluxos de trabalho que minimizem a aÃ§Ã£o de copiar e colar.

## Regras gerais

Para ajudar na compreensÃ£o e facilitar a comunicaÃ§Ã£o do time, devem-se adotar alguns padrÃµes

Nomes de variÃ¡vel em portuguÃªs, sempre que possÃ­vel, exceto convenÃ§Ãµes (*main, peek, push, tail etc*)
Componentes simples, pequenos, fÃ¡ceis de entender
NÃ£o usar funÃ§Ãµes complicadas
NÃ£o usar lÃ³gica complicada
NÃ£o usar cÃ³digo duplicado
Evitar ReferÃªncia Circular

Nomenclatura de variÃ¡veis
```C
nomeVariavel  //pascalCase
NomeStruct    //CamelCase
nome_funcao() //snake_case()
```

## OrganizaÃ§Ã£o das pastas

Adotamos uma estrutura modular e escalÃ¡vel, ideal para um time de 3 pessoas com papÃ©is claros (Tecnologia, DomÃ­nio e AplicaÃ§Ã£o).

ğŸ¯ Objetivo

Organizar o projeto em camadas:

```C
lib/ â†’ infraestrutura genÃ©rica (listas, Ã¡rvores, utilitÃ¡rios)

models/ â†’ definiÃ§Ãµes de structs de domÃ­nio (Produto, Cliente, etc.)

src/ â†’ aplicaÃ§Ã£o principal (lÃ³gica de negÃ³cio, main)

include/ â†’ headers (.h) de toda a aplicaÃ§Ã£o, para controle claro de dependÃªncias

ğŸ“ Estrutura de pastas
meu_programa/
â”‚
â”œâ”€â”€ include/                    # CabeÃ§alhos pÃºblicos
â”‚   â”œâ”€â”€ listagenerica.h
â”‚   â”œâ”€â”€ arvore.h
â”‚   â”œâ”€â”€ produto.h
â”‚   â”œâ”€â”€ cliente.h
â”‚   â””â”€â”€ app.h
â”‚
â”œâ”€â”€ lib/                        # ImplementaÃ§Ãµes genÃ©ricas e reutilizÃ¡veis
â”‚   â”œâ”€â”€ listagenerica.c
â”‚   â””â”€â”€ arvore.c
â”‚
â”œâ”€â”€ models/                     # Modelos de domÃ­nio
â”‚   â”œâ”€â”€ produto.c
â”‚   â””â”€â”€ cliente.c
â”‚
â”œâ”€â”€ src/                        # CÃ³digo da aplicaÃ§Ã£o
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ cadastro.c
â”‚   â”œâ”€â”€ login.c
â”‚   â””â”€â”€ entrega.c
â”‚
â”œâ”€â”€ Makefile                    # AutomaÃ§Ã£o de build
â””â”€â”€ README.md
```

## ğŸ‘¨â€ğŸ’» DivisÃ£o de responsabilidades (para o time)

Papel	DiretÃ³rio principal	Responsabilidade
Gerente TÃ©cnico	lib/, include/	MantÃ©m as tecnologias genÃ©ricas (lista, Ã¡rvore, hash, etc.)
Desenvolvedor de DomÃ­nio	models/	Define e mantÃ©m as structs e suas funÃ§Ãµes especÃ­ficas (Produto, Cliente, etc.)
Equipe de Customer Success / AplicaÃ§Ã£o	src/	Usa as libs e modelos para criar as regras do negÃ³cio e interface do programa
ğŸ§± Exemplo: include/listagenerica.h
#ifndef LISTAGENERICA_H
#define LISTAGENERICA_H

typedef struct Nodo {
    void *dados;
    struct Nodo *prox;
    struct Nodo *ant;
} Nodo;

typedef struct {
    Nodo *inicio;
    Nodo *fim;
    int tamanho;
} ListaGenerica;

ListaGenerica *criar_lista();
void inserir(ListaGenerica *lista, void *dados);
void *buscar(ListaGenerica *lista, int (*comparar)(void*, void*), void *chave);
void liberar_lista(ListaGenerica *lista, void (*destruir)(void*));

#endif

âš™ï¸ Exemplo: lib/listagenerica.c
#include <stdio.h>
#include <stdlib.h>
#include "../include/listagenerica.h"

ListaGenerica *criar_lista() {
    ListaGenerica *lista = malloc(sizeof(ListaGenerica));
    lista->inicio = lista->fim = NULL;
    lista->tamanho = 0;
    return lista;
}

void inserir(ListaGenerica *lista, void *dados) {
    Nodo *n = malloc(sizeof(Nodo));
    n->dados = dados;
    n->prox = NULL;
    n->ant = lista->fim;
    if (lista->fim)
        lista->fim->prox = n;
    else
        lista->inicio = n;
    lista->fim = n;
    lista->tamanho++;
}

ğŸ“¦ Exemplo: models/produto.c
#include <stdio.h>
#include <stdlib.h>
#include "../include/produto.h"

Produto *criar_produto(int id, const char *nome, float valor) {
    Produto *p = malloc(sizeof(Produto));
    p->id = id;
    snprintf(p->nome, sizeof(p->nome), "%s", nome);
    p->valor = valor;
    return p;
}

void exibir_produto(Produto *p) {
    printf("ID: %d | Nome: %s | Valor: %.2f\n", p->id, p->nome, p->valor);
}

ğŸ§© Exemplo: include/produto.h
#ifndef PRODUTO_H
#define PRODUTO_H

typedef struct {
    int id;
    char nome[100];
    float valor;
} Produto;

Produto *criar_produto(int id, const char *nome, float valor);
void exibir_produto(Produto *p);

#endif

ğŸš€ Exemplo: src/main.c
#include <stdio.h>
#include "../include/listagenerica.h"
#include "../include/produto.h"

int main() {
    printf("=== Sistema de Cadastro ===\n");

    ListaGenerica *listaProdutos = criar_lista();

    Produto *p1 = criar_produto(1, "Arroz", 10.50);
    Produto *p2 = criar_produto(2, "FeijÃ£o", 8.90);

    inserir(listaProdutos, p1);
    inserir(listaProdutos, p2);

    exibir_produto(p1);
    exibir_produto(p2);

    return 0;
}

ğŸ§° Makefile simples
CC = gcc
CFLAGS = -Iinclude -Wall
OBJ = lib/listagenerica.o models/produto.o src/main.o

meu_programa: $(OBJ)
	$(CC) -o $@ $(OBJ)

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -f $(OBJ) meu_programa

ğŸ’¡ BenefÃ­cios dessa organizaÃ§Ã£o

âœ… Cada Ã¡rea tem autonomia sem interferir nas outras.
âœ… Facilita testes isolados (por ex. make test-lib para testar lib/).
âœ… Padroniza inclusÃ£o de headers (#include "../include/...").
âœ… Evita dependÃªncias circulares.
âœ… FÃ¡cil expansÃ£o â€” basta adicionar novas structs em models/.
